//takeEvery слушает каждый актион попадающий в сага
import { takeLatest, call, put } from 'redux-saga/effects';

import {
  firestore,
  convertCollectionsSnapshotToMap,
} from '../../firebase/firebase.utils';
import ShopActionTypes from './shop.types';
import {
  fetchCollectionsFailure,
  fetchCollectionsSuccess,
} from './shop.actions';
export function* fetchCollectionsAsunc() {
  try {
    const collectionRef = firestore.collection('collections');
    const snapshot = yield collectionRef.get();
    // yield call() так в сагах вызываются функции
    const collectionsMap = yield call(
      convertCollectionsSnapshotToMap,
      snapshot
    );
    //yield put это аналог диспачча в саге
    yield put(fetchCollectionsSuccess(collectionsMap));
  } catch (error) {
    put(fetchCollectionsFailure(error));
  }
}

// если загорается акшн с типом FETCH_COLLECTIONS_START, то takeEvery вызовет fetchCollectionsAsunc
export function* fetchCollectionsStart() {
  yield takeLatest(
    ShopActionTypes.FETCH_COLLECTIONS_START,
    fetchCollectionsAsunc
  );
}

// смысл саг в том что они работают паралельно
//takeEvery создает неблокирующий вызов чтобы не стопить наш джс код

// путь такой актионкреатор загорается и сага перехватывает акион прежде чем он попадет в редюсер

// yield call() так в сагах вызываются функции первый аргументт это функция а последующие это аргумменты. мы можем просто прописать вызов функции как обычно но, тогда он не будет нонблокинг и может тормохить наш апп. поэтому мы юзаем такой вызов функции, на случай если опперация этой функции займет много времени. а редукс сага дает нам нонблокинг. но это не точно. кароче так вызываюься функции в саге

// put это аналог диспача. он зажигает актионкреатор, который возвращает актион объект и возращет его обратно в наш редукс поток. в редюсеры или в другие саги, если они слушают тип который есть у нашего созданного путом актиона

//take принимает в себя только тип(без функции как c takeEvery)
// что делает take. он ждет когда актион загорится и если это случилось то он возращает нам пэйлоад этого актиона. еще как и такэври последующий код не вызовется пока не разрешиться тэйк
// еще разница между take и takeEvery в том что тэйкэври срабатывает каждый раз когда актион загорается, а take только оддин раз. так происходит потому что тайк следует логикике генераторфункции, которая гласит что если иелдов не осталось то done: true и следовательно функция выполнилась полностью. и поэтому мы не сможем рестартунть эту сагу. а c Take Evry ситуация такая что редук- сага каждый раз как актион загорается пересоздает функцию-генератор (которая передается в тейк еври). и каждый раз у нас вызывается новая пересозданная под копотом функция генеоатор(заметь вызывается не одна и та же функциягенератор, а пересоздается новая каждый раз)

// export function* incrementSaga() {
//   const incrementPayload = yield take('INCREMENT');
//   console.log(
//     'я не заработаю до тех пор пока incrementPayload = yield take("INCREMENT"); не воспроизведется'
//   );
// }

// while(true) {
//   yield take('INCREMENT');
//   console.log(('я могу вызваться много раз'));
// }

//это полиморф тайкеври но если мы сюда добавим delay то испонение фрозится на время этого делея.
//такое стопание полезно если мы хотим дебаунсить какую то операцию(например ввод текста форму)

// while(true) {
//   yield take('INCREMENT');
//   console.log(('я могу вызваться много раз'));
// yield delay(5000)
// }

// в отличии от тейк эври, который не стопится из за асинхроннх операции(делей это асинхроная операция) мы можем задать делей в функцию гереатор которая передается в тайк еври  и это не застопит наше исполнение кода в приложении
// еще особенностью тейк еври является то что если мы несколько раз сразу подряд зажжем актионы, и у нас заведется операция по по фетччингу с сервера вывполнение которых занимает время, то он будет сразу выполнять эти запросы пралельно(по факту фетчится одна фигня), но запросили мы много раз. и это нежелательно, так нагружается приложение. чтобы этого избежать юзают takeLаtest который будет обрабатывать последний запрос на сервер фетч(в функции генераторе который мы в него передаем(saga) который мы совершили. отменяя недозовершенные до него функции генераторы(саги)
